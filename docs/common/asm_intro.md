# 龙芯汇编介绍

> 本介绍参考自[《龙芯架构参考手册 - 卷一：基础架构》](https://github.com/loongson/LoongArch-Documentation/releases/latest/download/LoongArch-Vol1-v1.02-CN.pdf)。

龙芯架构 LoongArch 时一种精简指令集计算机（RISC）风格的指令系统架构，在本次实验中，我们主要关注龙芯架构中的非向量整数和非向量浮点指令。

<!--分为 32 位和 64 位两个版本，分别称为 LA32 架构和 LA64 架构。其中 LA64 架构应用级向下二进制兼容 LA32 架构，即采用 LA32 架构的**应用软件**（不包括操作系统内核等系统软件）的二进制可以直接运行在兼容 LA64 架构的机器上并取得相同的运行结果。-->

如下是一段 C 语言代码 `easy.c` 与其对应的龙芯汇编 `easy.s` 示例。

- `easy.c`

  ```c
  int main(void) {
    int a;
    int b;
    a = 1;
    b = 2;
    return a + b;
  }
  ```

- `easy.s`

  ```assembly
  	.text
  	.globl main
  	.type main, @function
  main:
  	st.d $ra, $sp, -8
  	st.d $fp, $sp, -16
  	addi.d $fp, $sp, 0
  	addi.d $sp, $sp, -64
  .main_label_entry:
  # %op0 = alloca i32
  	addi.d $t0, $fp, -28
  	st.d $t0, $fp, -24
  # %op1 = alloca i32
  	addi.d $t0, $fp, -40
  	st.d $t0, $fp, -36
  # store i32 1, i32* %op0
  	addi.w $t0, $zero, 1
  	ld.d $t1, $fp, -24
  	st.w $t0, $t1, 0
  # store i32 2, i32* %op1
  	addi.w $t0, $zero, 2
  	ld.d $t1, $fp, -36
  	st.w $t0, $t1, 0
  # %op2 = load i32, i32* %op0
  	ld.d $t0, $fp, -24
  	ld.w $t0, $t0, 0
  	st.w $t0, $fp, -44
  # %op3 = load i32, i32* %op1
  	ld.d $t0, $fp, -36
  	ld.w $t0, $t0, 0
  	st.w $t0, $fp, -48
  # %op4 = add i32 %op2, %op3
  	ld.w $t0, $fp, -44
  	ld.w $t1, $fp, -48
  	add.w $t2, $t0, $t1
  	st.w $t2, $fp, -52
  # ret i32 %op4
  	ld.w $a0, $fp, -52
  	b main_exit
  main_exit:
  	addi.d $sp, $sp, 64
  	ld.d $ra, $sp, -8
  	ld.d $fp, $sp, -16
  	jr $ra
  ```

## 汇编助记格式

龙芯架构对指令名和操作数的前、后缀进行了统一考虑，以方便汇编编程人员和编译器开发人员使用，例如 `fadd.s` 指令为“单精度”“浮点”加法指令。

### 指令名前缀

龙芯架构指令前缀和指令类型的对应关系为：

| 指令前缀 | 指令类型         |
| -------- | ---------------- |
| 无前缀   | 非向量整数指令   |
| `f`      | 非向量浮点数指令 |
| ……       | ……               |

### 指令名后缀

其次，绝大多数指令通过指令名中 `.XX` 形式的后缀来指示指令的操作对象类型：

- 对于整数指令，后缀和操作对象类型的对应关系为

  | 指令后缀 | 操作对象类型 |  操作对象长度  |
  | :------: | :----------: | :------------: |
  |   `.b`   |  有符号字节  | 1 字节 / 8 位  |
  |   `.h`   |  有符号半字  | 2 字节 / 16 位 |
  |   `.w`   |   有符号字   | 4 字节 / 32 位 |
  |   `.d`   |  有符号双字  | 8 字节 / 64 位 |
  |  `.bu`   |  无符号字节  | 1 字节 / 8 位  |
  |  `.hu`   |  无符号半字  | 2 字节 / 16 位 |
  |  `.wu`   |   无符号字   | 4 字节 / 32 位 |
  |  `.du`   |  无符号双字  | 8 字节 / 64 位 |

  !!! info "特殊情况"

      当操作数是有符号数还是无符号数不影响运算结果时，指令名中携带的后缀均不含 `u`，但是并不意味着指令的操作对象只能是有符号数。

- 对于浮点数指令，后缀和指令类型的对应关系为

  | 指令后缀 | 操作对象类型 |  操作对象长度  |
  | :------: | :----------: | :------------: |
  |   `.h`   | 半精度浮点数 | 2 字节 / 16 位 |
  |   `.s`   | 单精度浮点数 | 4 字节 / 32 位 |
  |   `.d`   | 双精度浮点数 | 8 字节 / 64 位 |
  |   `.w`   |   有符号字   | 4 字节 / 32 位 |
  |   `.l`   |  有符号双字  | 8 字节 / 64 位 |
  |  `.wu`   |   无符号字   | 4 字节 / 32 位 |
  |  `.lu`   |  无符号双字  | 8 字节 / 64 位 |

当源操作数和目的操作数的数据位宽和有无符号情况一致时，指令名只有一个后缀。但是如果源操作数的数据位宽和有无符号情况一致，但和目的操作数不一致时，那么指令名将有两个后缀：

- 左边的后缀表示目的操作数的情况
- 右边的操作数表示源操作数的情况

比如，将长整数型定点数（有符号双字）转化为单精度浮点数的指令名为 `ffint.s.l`。

更复杂的数据位宽情况这里不做讨论，感兴趣的同学可以自行查阅[《龙芯架构参考手册 - 卷一：基础架构》](https://github.com/loongson/LoongArch-Documentation/releases/latest/download/LoongArch-Vol1-v1.02-CN.pdf)的 1.3 章节。

### 寄存器首字母

寄存器操作数通过不同的首字母表明其属于哪个寄存器文件。对于非向量寄存器，以 `$rN` 标记通用寄存器，`$fN` 标记浮点寄存器。其中 `N` 是数字，表示操作的时该寄存器文件中的第 N 号寄存器。

## 通用寄存器

整数指令涉及的寄存器包括**通用寄存器** GR 和**程序计数器** PC。

其中通用寄存器有 32 个，记为 `$r0` ~ `$r31`，其中第 0 号寄存器 `$r0` 的值恒为 `0`。在龙芯架构 ELF psABI 规范中，通用寄存器遵循如下的使用规定：

|      名称       |     别名      |           用途           | 在调用中是否保留 |
| :-------------: | :-----------: | :----------------------: | :--------------: |
|      `$r0`      |    `$zero`    |         常数 `0`         |     （常数）     |
|      `$r1`      |     `$ra`     |         返回地址         |        否        |
|      `$r2`      |     `$tp`     |         线程指针         |   （不可分配）   |
|      `$r3`      |     `$sp`     |          栈指针          |        是        |
|  `$r4` - `$r5`  | `$a0` - `$a1` | 传参寄存器、返回值寄存器 |        否        |
| `$r6` - `$r11`  | `$a2` - `$a7` |        传参寄存器        |        否        |
| `$r12` - `$r20` | `$t0` - `$t8` |        临时寄存器        |        否        |
|     `$r21`      |               |           保留           |   （不可分配）   |
|     `$r22`      | `$fp` / `$s9` |  栈帧指针 / 静态寄存器   |        是        |
| `$r23` - `$r31` | `$s0` - `$s8` |        静态寄存器        |        是        |

如果“在调用中是否保留”标志为“是”，则表示在调用函数后，寄存器中的值不会发生更改，这意味着被调用的函数需要确保在返回之前还原这些寄存器的值。

## 浮点寄存器

浮点数指令涉及到的寄存器包括**浮点寄存器** FR、**条件标志寄存器** CFR 和**浮点控制状态寄存器** FCSR。我们将着重介绍前两种寄存器。

### 浮点寄存器

浮点寄存器共有 32 个，记为 `$f0` ~ `$f31`，每一个都可以读写。在龙芯架构 ELF psABI 规范中，浮点寄存器遵循如下的使用规定：

|      名称       |       别名       |           用途           | 在调用中是否保留 |
| :-------------: | :--------------: | :----------------------: | :--------------: |
|  `$f0` - `$f1`  | `$fa0` - `$fa1`  | 传参寄存器、返回值寄存器 |        否        |
|  `$f2` - `$f7`  | `$fa2` - `$fa7`  |        传参寄存器        |        否        |
| `$f8` - `$f23`  | `$ft0` - `$ft15` |        临时寄存器        |        否        |
| `$f24` - `$f31` | `$fs0` - `$fs7`  |        静态寄存器        |        是        |

如果“在调用中是否保留”标志为“是”，则表示在调用函数后，寄存器中的值不会发生更改，这意味着被调用的函数需要确保在返回之前还原这些寄存器的值。

### 条件标志寄存器

条件标志寄存器共有 8 个，记为 `$fcc0` ~ `$fcc7`，每一个都可以读写，位宽为 1 比特。

- **浮点比较**的结果将写到条件标志寄存器中，比较结果为真时置 `1`，否则置 `0`。
- **浮点分支指令的判断条件**来自条件标志寄存器。

## 整数指令

在龙芯架构中，基础整数指令操作的数据类型有 5 种：

| 数据类型 |    英文    | 简记 | 长度 |
| :------: | :--------: | :--: | :--: |
|   比特   |    bit     |  b   |  1b  |
|   字节   |    Byte    |  B   |  8b  |
|   半字   |  Halfword  |  H   | 16b  |
|    字    |    Word    |  W   | 32b  |
|   双字   | Doubleword |  D   | 64b  |

字节、半字、字和双字数据类型均采用二进制补码的编码方式。

<!-- TODO 整数指令 -->

### 算数运算指令

### 移位运算指令

### 位操作指令

### 跳转指令

### 普通访存指令

## 浮点数指令

在龙芯架构中，浮点数据类型包括单精度浮点数和双精度浮点数，二者均遵循 IEEE 754-2008 标准规范中的定义。部分浮点指令（如浮点转换指令）也会涉及定点（整数）数据，包括字（Word，简记 W，长度 32b）和长字（Longword，简记 L，长度 64b），它们均采用二进制补码的编码方式。

### 浮点运算指令

### 浮点转换指令

### 浮点搬运指令

### 浮点普通访存指令

### 浮点比较指令

### 浮点分支指令

## GNU 汇编伪指令

由于我们生成的汇编代码最终会被 GNU 工具链中的 Assembler 翻译为机器语言，所以汇编代码中会包含一些 **GNU 汇编伪指令**，我们将在这一节简要介绍我们需要的伪指令。如果想要更进一步了解 GNU 汇编伪指令，可以参考 [Assembler Directives](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html)。

<!-- TODO 浮点数指令 -->

<!--TODO 例子-->

<!--TODO 官方文档引用-->
