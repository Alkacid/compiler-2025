# Lab3 实验指导

一个典型的编译器后端从中间代码获取信息，进行活跃变量分析、寄存器分配、指令选择、指令优化等一系列流程，最终生成高质量的后端代码。

本次实验，我们将这些复杂的流程简化，仅追求实现的完整性，要求同学们采用栈式分配的策略，完成后端代码生成。

## 栈式分配

<!--TODO 更详细的介绍、单独一个文件-->

栈式分配，是指**程序的所有变量都保存在栈上**，只在参与计算时提取到寄存器中。

在栈式分配策略下，编译器后端主要分为两个步骤：

1. 变量分配：为程序中的每个变量分配一个栈帧位置，即相对栈指针的一个偏移量

2. 指令选择：对于指令 $u= v_1 \ op\ v_2$

   1. 将两个操作数（$op_1$ 和 $op_2$）对应的数据分别从栈上提取到寄存器中（load 指令）
   2. 根据指令类型选择合适的汇编指令（可能有多条）
   3. 将计算结果存储到栈上（store 指令）

而在寄存器分配策略下，变量活跃期间都保留在各自的寄存器中，不需要 2.a 的 load 和 2.c 的 store。所以性能上，栈式分配不如寄存器分配，而在实现难度上，栈式分配要简单许多。

## 实验框架

阅读 [后端框架介绍](framework.md) 章节。

## 实现约定

出于简化实验的目的，我们只考核最核心的功能点，对如下情况不做要求：

- phi 指令：本实验不考核对于 phi 指令的处理
- 函数调用传参：本次实验只考核使用寄存器传参的情况，即对于超多参数的栈上传参不做要求

此外，存在部分 `void main() {...}` 的样例，其返回值是未定义的，我们要求这样的主函数通过寄存器 `$a0` 返回 0，以顺利进行测评。

## 本地评测

!!! warning "编译"

    评测之前，确保你已经在项目 `build` 目录下进行了 `sudo make install`，使程序 `cminusfc` 是最新版本。详情可以查询[ lab2 的相关章节](../lab2/autogen.md#编译运行和评测)。

在 `tests/3-codegen` 目录下，使用我们提供的 `eval_lab3.sh` 进行本地评测，其接受两个参数：

1. 测试样例目录：考核的两个测例目录分别是 `tests/3-codegen/testcases` 和 `tests/testcases_general`
1. 评测模式：`test` 只生成并汇编并测试其正确性，`debug` 将同时输出 `.ll` 文件

评测脚本会生成 `output` 目录和 `log.txt` 文件，出现错误时请查阅相关文件。

在结束测评后，使用 `./cleanup.sh` 清空输出文件。
